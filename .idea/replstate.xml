<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1430623041308">{:repl-history {:ide [], :local [&quot;(take 6 (let [index-stream (cycle (range (count words)))]\n   (repeatedly (partial nth words (first index-stream))))) &quot; &quot;(take 3 index-stream)&quot; &quot;(fn [] (cycle words))&quot; &quot;(def known-stream *1)&quot; &quot;(known-stream)&quot; &quot;(def white-space-re #\&quot;\\s\&quot;)&quot; &quot;(def words (clojure.string/split \&quot;lorem ipsum dolor sit amet\&quot; white-space-re))&quot; &quot;(defn f [] (first (cycle words)))&quot; &quot;(f)&quot; &quot;(first (cycle [\&quot;lorem\&quot; \&quot;ipsum\&quot; \&quot;dolor\&quot; \&quot;sit\&quot; \&quot;amet\&quot;]))&quot; &quot;(defn c-stream (cycle (range 5)))&quot; &quot;(def c-stream (cycle (range 5)))&quot; &quot;(take 5 c-stream)&quot; &quot;(take 3 c-stream)&quot; &quot;(def rc-stream (let [c-stream (cycle (range 5)) (repeatedly (fn [] (first c-stream)))])) &quot; &quot;(def rc-stream (let [c-stream (cycle (range 5))] (repeatedly (fn [] (first c-stream))))) &quot; &quot;(take 3 rc-stream)&quot; &quot;(def white-space-re #\&quot;\\s+\&quot;)&quot; &quot;(def words (clojure.string/split text white-space-re))&quot; &quot;(def rand-words (repeatedly (fn [] (rand-nth words))))&quot; &quot;(take 5 (repeatedly (fn [] (rand-nth words))))&quot; &quot;(take 3 rand-words)&quot; &quot;(take 3 (repeatedly (partial cycle words)))&quot; &quot;(def password-sequence (repeatedly (partial rand-nth words)))&quot; &quot;(def text \&quot;lorem ipsum dolor sit amet\&quot;)&quot; &quot;(def words (clojure.string/split #\&quot;\\s+\&quot; text))&quot; &quot;(def words (clojure.string/split text #\&quot;\\s+\&quot;))&quot; &quot;(def random-word-sequence (repeatedly (rand-nth words)))&quot; &quot;(def random-char-sequence (repeatedly (rand-nth \&quot;0123456789\&quot;)))&quot; &quot;(take 1 (random-char-sequence))&quot; &quot;(take 1 random-char-sequence)&quot; &quot;(first \&quot;01234\&quot;)&quot; &quot;(rand-nth \&quot;01234\&quot;)&quot; &quot;(def random-char-sequence (repeatedly (partial rand-nth words)))&quot; &quot;(def random-word-sequence random-char-sequence)&quot; &quot;(def random-char-sequence (repeatedly (partial rand-nth \&quot;0123456789\&quot;)))&quot; &quot;(take 3 (interleave random-word-sequence random-char-sequence random-word-sequence))&quot; &quot;(take 3 random-word-sequence)&quot; &quot;(first (interleave random-word-sequence))&quot; &quot;(first (interleave random-word-sequence random-char-sequence))&quot; &quot;(interleave (range 5) (range 5 10))&quot; &quot;(take 3 (map vec random-word-sequence random-char-sequence random-word-sequence))&quot; &quot;(take 3 (map (vec %1 %2 %3) random-word-sequence random-char-sequence random-word-sequence))&quot; &quot;(take 3 (map #(vec %1 %2 %3) random-word-sequence random-char-sequence random-word-sequence))&quot; &quot;(doc vec)&quot; &quot;(take 3 (map #(apply vec %1 %2 %3) random-word-sequence random-char-sequence random-word-sequence))&quot; &quot;(take 3 (map #([%1 %2 %3]) random-word-sequence random-char-sequence random-word-sequence))&quot; &quot;(doc vector)&quot; &quot;(take 3 (map vector random-word-sequence random-char-sequence random-word-sequence))&quot; &quot;(def really-weird-stuff (repeatedly (fn [] (println \&quot;Here\&quot;) (rand-nth words))))&quot; &quot;(take 3 really-weird-suff)&quot; &quot;(take 3 really-weird-stuff)&quot; &quot;(defn random-words [] (first random-word-sequence))&quot; &quot;(dotimes [n 3] (println (random-words)))&quot; &quot;(take 3 (repeatedly (partial rand-nth words)))&quot; &quot;(take 3 (map #(vector %1 %2 %3) (repeatedly (partial rand-nth words) (repeatedly (partial rand-nth \&quot;0123456789\&quot;) (repeatedly (partial rand-nth words))))))&quot; &quot;(take 3 (map #(vector %1 %2 %3) (repeatedly (partial rand-nth words)) (repeatedly (partial rand-nth \&quot;0123456789\&quot;)) (repeatedly (partial rand-nth words))))&quot; &quot;(defn next-word [words]\n  (let [s (repeatedly (partial rand-nth words))]\n    (loop [w (first s)]\n      w\n      (recur (rest s)))))&quot; &quot;(def word-gen (let [indices (iterate #(if (= %1 (count words) 0) (int %1)) 0)]\n                (fn [w] (nth words indices))))&quot; &quot;(def word-gen (let [indices (iterate #(if (= %1 (count words) 0) (inc %1)) 0)]\n                (fn [w] (nth words indices))))&quot; &quot;(word-gen words)&quot; &quot;(take 6 (iterate #(if (= %1 (count words) 0) (inc %1)) 0))&quot; &quot;(take 6 (iterate #(if (= %1 (count words)) 0 (inc %1)) 0))&quot; &quot;(take 7 (iterate #(if (= %1 (count words)) 0 (inc %1)) 0))&quot; &quot;(defn foo [n] (if (= n (count words)) 0 (inc n)))&quot; &quot;(dotimes [n 6] (println n))&quot; &quot;(defn foo [n] (inc n) (if (= n (count words)) 0 n))&quot; &quot;(dotimes [n 6] (println (foo n)))&quot; &quot;(take 6 (iterate (fn [n] (inc n) (if (= n (count words)) 0 n))))&quot; &quot;(take 6 (iterate (fn [n] (inc n) (if (= n (count words)) 0 n)) 0))&quot; &quot;(take 6 (iterate (fn [n] (if (= (inc n) (count words)) 0 (inc n))) 0))&quot; &quot;(take 3 (cycle words))&quot; &quot;(let [w (cycle words)]\n  (dorun (println (take 3 w)) (println (take 3 w))))&quot; &quot;(def words [\&quot;lorem ipsum dolor sit amet\&quot;])&quot; &quot;(doseq [expected words]\n  (println \&quot;expected \&quot; expected)\n  (println #(nth words (swap! prev-words-index inc))))&quot; &quot;(doseq [expected words]\n  (println \&quot;expected \&quot; expected)\n  (println #(nth words (swap! prev-words-index inc)) ()))&quot; &quot;@prev-words-index&quot; &quot;(swap! prev-words-index inc)&quot; &quot;(defn foo [w]\n  (let [next-word-index (swap! prev-words-index inc)\n        _ println (\&quot;next\&quot; next-word-index)]\n    (nth w next-word-index)))&quot; &quot;(defn foo [w]\n  (let [next-word-index (swap! prev-words-index inc)\n        _ println(str \&quot;next\&quot; next-word-index)]\n    (nth w next-word-index)))&quot; &quot;(defn foo [w]\n  (let [next-word-index (swap! prev-words-index inc)\n        _r println(str \&quot;next\&quot; next-word-index)]\n    (nth w next-word-index)))&quot; &quot;(defn foo [w]\n  (let [next-word-index (swap! prev-words-index inc)]\n    (nth w next-word-index)))&quot; &quot;(foo)&quot; &quot;(def words [\&quot;lorem\&quot; \&quot;ipsum\&quot; \&quot;dolor\&quot; \&quot;sit\&quot; \&quot;amet\&quot;])&quot; &quot;(foo words)&quot; &quot;(def prev-words-index (atom -1))&quot; &quot;(doseq [expected words])&quot; &quot;(defn foo [w]\n  (let [next-word-index (swap! prev-words-index inc)\n        _ (println \&quot;index\&quot; next-word-index)]\n    (nth w next-word-index)))&quot; &quot;(dotimes [n 5] (foo words))&quot; &quot;(char 33)&quot; &quot;(char 32\n      )&quot; &quot;(require '[clojure.string :as str])&quot; &quot;(str/join (map char (range 33 64)))&quot; &quot;(require '[mem-pwds.core :as mpc])&quot; &quot;(mpc/next-password [\&quot;lorem\&quot; \&quot;ipsum\&quot; \&quot;dolor\&quot; \&quot;sit\&quot; \&quot;amet\&quot;])&quot; &quot;(def words (str/split \&quot;lorem ipsum dolor sit amet\&quot;))&quot; &quot;words&quot; &quot;(require '[clojure.string :as str]\n         '[mem-pwds.core :as mpc])&quot; &quot;(def words (str/split \&quot;lorem ipsum dolor sit amet\&quot; #\&quot;\\s\&quot;))&quot; &quot;(count words)&quot; &quot;(mpc/next-password words)&quot;], :remote []}}</component>
</project>